// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod a6 {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_METHOD: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_METHOD: u8 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_METHOD: [Method; 15] = [
  Method::GET,
  Method::HEAD,
  Method::POST,
  Method::PUT,
  Method::DELETE,
  Method::MKCOL,
  Method::COPY,
  Method::MOVE,
  Method::OPTIONS,
  Method::PROPFIND,
  Method::PROPPATCH,
  Method::LOCK,
  Method::UNLOCK,
  Method::PATCH,
  Method::TRACE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Method(pub u8);
#[allow(non_upper_case_globals)]
impl Method {
  pub const GET: Self = Self(0);
  pub const HEAD: Self = Self(1);
  pub const POST: Self = Self(2);
  pub const PUT: Self = Self(3);
  pub const DELETE: Self = Self(4);
  pub const MKCOL: Self = Self(5);
  pub const COPY: Self = Self(6);
  pub const MOVE: Self = Self(7);
  pub const OPTIONS: Self = Self(8);
  pub const PROPFIND: Self = Self(9);
  pub const PROPPATCH: Self = Self(10);
  pub const LOCK: Self = Self(11);
  pub const UNLOCK: Self = Self(12);
  pub const PATCH: Self = Self(13);
  pub const TRACE: Self = Self(14);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::GET,
    Self::HEAD,
    Self::POST,
    Self::PUT,
    Self::DELETE,
    Self::MKCOL,
    Self::COPY,
    Self::MOVE,
    Self::OPTIONS,
    Self::PROPFIND,
    Self::PROPPATCH,
    Self::LOCK,
    Self::UNLOCK,
    Self::PATCH,
    Self::TRACE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::GET => Some("GET"),
      Self::HEAD => Some("HEAD"),
      Self::POST => Some("POST"),
      Self::PUT => Some("PUT"),
      Self::DELETE => Some("DELETE"),
      Self::MKCOL => Some("MKCOL"),
      Self::COPY => Some("COPY"),
      Self::MOVE => Some("MOVE"),
      Self::OPTIONS => Some("OPTIONS"),
      Self::PROPFIND => Some("PROPFIND"),
      Self::PROPPATCH => Some("PROPPATCH"),
      Self::LOCK => Some("LOCK"),
      Self::UNLOCK => Some("UNLOCK"),
      Self::PATCH => Some("PATCH"),
      Self::TRACE => Some("TRACE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Method {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Method {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Method {
    type Output = Method;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Method {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Method {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Method {}
pub enum TextEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TextEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TextEntry<'a> {
  type Inner = TextEntry<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> TextEntry<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TextEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TextEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<TextEntry<'bldr>> {
    let mut builder = TextEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TextEntry::VT_NAME, None)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TextEntry::VT_VALUE, None)
  }
}

impl flatbuffers::Verifiable for TextEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct TextEntryArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TextEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    TextEntryArgs {
      name: None,
      value: None,
    }
  }
}

pub struct TextEntryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TextEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TextEntry::VT_NAME, name);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TextEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TextEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TextEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TextEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TextEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TextEntry");
      ds.field("name", &self.name());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum DataEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DataEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataEntry<'a> {
  type Inner = DataEntry<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> DataEntry<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DataEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DataEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<DataEntry<'bldr>> {
    let mut builder = DataEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataEntry::VT_NAME, None)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DataEntry::VT_VALUE, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for DataEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct DataEntryArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for DataEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    DataEntryArgs {
      name: None,
      value: None,
    }
  }
}

pub struct DataEntryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DataEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataEntry::VT_NAME, name);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DataEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DataEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DataEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DataEntry");
      ds.field("name", &self.name());
      ds.field("value", &self.value());
      ds.finish()
  }
}
#[allow(unused_imports, dead_code)]
pub mod err {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CODE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CODE: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CODE: [Code; 3] = [
  Code::BAD_REQUEST,
  Code::SERVICE_UNAVAILABLE,
  Code::CONF_TOKEN_NOT_FOUND,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Code(pub u8);
#[allow(non_upper_case_globals)]
impl Code {
  pub const BAD_REQUEST: Self = Self(0);
  pub const SERVICE_UNAVAILABLE: Self = Self(1);
  pub const CONF_TOKEN_NOT_FOUND: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::BAD_REQUEST,
    Self::SERVICE_UNAVAILABLE,
    Self::CONF_TOKEN_NOT_FOUND,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::BAD_REQUEST => Some("BAD_REQUEST"),
      Self::SERVICE_UNAVAILABLE => Some("SERVICE_UNAVAILABLE"),
      Self::CONF_TOKEN_NOT_FOUND => Some("CONF_TOKEN_NOT_FOUND"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Code {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Code {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Code {
    type Output = Code;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Code {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Code {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Code {}
pub enum RespOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Resp<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Resp<'a> {
  type Inner = Resp<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Resp<'a> {
  pub const VT_CODE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Resp { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RespArgs
  ) -> flatbuffers::WIPOffset<Resp<'bldr>> {
    let mut builder = RespBuilder::new(_fbb);
    builder.add_code(args.code);
    builder.finish()
  }


  #[inline]
  pub fn code(&self) -> Code {
    self._tab.get::<Code>(Resp::VT_CODE, Some(Code::BAD_REQUEST)).unwrap()
  }
}

impl flatbuffers::Verifiable for Resp<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Code>("code", Self::VT_CODE, false)?
     .finish();
    Ok(())
  }
}
pub struct RespArgs {
    pub code: Code,
}
impl<'a> Default for RespArgs {
  #[inline]
  fn default() -> Self {
    RespArgs {
      code: Code::BAD_REQUEST,
    }
  }
}

pub struct RespBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RespBuilder<'a, 'b> {
  #[inline]
  pub fn add_code(&mut self, code: Code) {
    self.fbb_.push_slot::<Code>(Resp::VT_CODE, code, Code::BAD_REQUEST);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RespBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RespBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Resp<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Resp<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Resp");
      ds.field("code", &self.code());
      ds.finish()
  }
}
}  // pub mod Err

#[allow(unused_imports, dead_code)]
pub mod prepare_conf {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum ReqOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Req<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Req<'a> {
  type Inner = Req<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Req<'a> {
  pub const VT_CONF: flatbuffers::VOffsetT = 4;
  pub const VT_KEY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Req { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReqArgs<'args>
  ) -> flatbuffers::WIPOffset<Req<'bldr>> {
    let mut builder = ReqBuilder::new(_fbb);
    if let Some(x) = args.key { builder.add_key(x); }
    if let Some(x) = args.conf { builder.add_conf(x); }
    builder.finish()
  }


  #[inline]
  pub fn conf(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry>>>>(Req::VT_CONF, None)
  }
  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Req::VT_KEY, None)
  }
}

impl flatbuffers::Verifiable for Req<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<super::TextEntry>>>>("conf", Self::VT_CONF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .finish();
    Ok(())
  }
}
pub struct ReqArgs<'a> {
    pub conf: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry<'a>>>>>,
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ReqArgs<'a> {
  #[inline]
  fn default() -> Self {
    ReqArgs {
      conf: None,
      key: None,
    }
  }
}

pub struct ReqBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReqBuilder<'a, 'b> {
  #[inline]
  pub fn add_conf(&mut self, conf: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<super::TextEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Req::VT_CONF, conf);
  }
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Req::VT_KEY, key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReqBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReqBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Req<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Req<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Req");
      ds.field("conf", &self.conf());
      ds.field("key", &self.key());
      ds.finish()
  }
}
pub enum RespOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Resp<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Resp<'a> {
  type Inner = Resp<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Resp<'a> {
  pub const VT_CONF_TOKEN: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Resp { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RespArgs
  ) -> flatbuffers::WIPOffset<Resp<'bldr>> {
    let mut builder = RespBuilder::new(_fbb);
    builder.add_conf_token(args.conf_token);
    builder.finish()
  }


  #[inline]
  pub fn conf_token(&self) -> u32 {
    self._tab.get::<u32>(Resp::VT_CONF_TOKEN, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for Resp<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("conf_token", Self::VT_CONF_TOKEN, false)?
     .finish();
    Ok(())
  }
}
pub struct RespArgs {
    pub conf_token: u32,
}
impl<'a> Default for RespArgs {
  #[inline]
  fn default() -> Self {
    RespArgs {
      conf_token: 0,
    }
  }
}

pub struct RespBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RespBuilder<'a, 'b> {
  #[inline]
  pub fn add_conf_token(&mut self, conf_token: u32) {
    self.fbb_.push_slot::<u32>(Resp::VT_CONF_TOKEN, conf_token, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RespBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RespBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Resp<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Resp<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Resp");
      ds.field("conf_token", &self.conf_token());
      ds.finish()
  }
}
}  // pub mod PrepareConf

#[allow(unused_imports, dead_code)]
pub mod httpreq_call {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ACTION: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ACTION: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ACTION: [Action; 3] = [
  Action::NONE,
  Action::Stop,
  Action::Rewrite,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Action(pub u8);
#[allow(non_upper_case_globals)]
impl Action {
  pub const NONE: Self = Self(0);
  pub const Stop: Self = Self(1);
  pub const Rewrite: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Stop,
    Self::Rewrite,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Stop => Some("Stop"),
      Self::Rewrite => Some("Rewrite"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Action {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Action {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Action {
    type Output = Action;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Action {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Action {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Action {}
pub struct ActionUnionTableOffset {}

pub enum ReqOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Req<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Req<'a> {
  type Inner = Req<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Req<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_SRC_IP: flatbuffers::VOffsetT = 6;
  pub const VT_METHOD: flatbuffers::VOffsetT = 8;
  pub const VT_PATH: flatbuffers::VOffsetT = 10;
  pub const VT_ARGS: flatbuffers::VOffsetT = 12;
  pub const VT_HEADERS: flatbuffers::VOffsetT = 14;
  pub const VT_CONF_TOKEN: flatbuffers::VOffsetT = 16;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Req { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReqArgs<'args>
  ) -> flatbuffers::WIPOffset<Req<'bldr>> {
    let mut builder = ReqBuilder::new(_fbb);
    builder.add_conf_token(args.conf_token);
    if let Some(x) = args.headers { builder.add_headers(x); }
    if let Some(x) = args.args { builder.add_args(x); }
    if let Some(x) = args.path { builder.add_path(x); }
    if let Some(x) = args.src_ip { builder.add_src_ip(x); }
    builder.add_id(args.id);
    builder.add_method(args.method);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u32 {
    self._tab.get::<u32>(Req::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn src_ip(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Req::VT_SRC_IP, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn method(&self) -> super::Method {
    self._tab.get::<super::Method>(Req::VT_METHOD, Some(super::Method::GET)).unwrap()
  }
  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Req::VT_PATH, None)
  }
  #[inline]
  pub fn args(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry>>>>(Req::VT_ARGS, None)
  }
  #[inline]
  pub fn headers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry>>>>(Req::VT_HEADERS, None)
  }
  #[inline]
  pub fn conf_token(&self) -> u32 {
    self._tab.get::<u32>(Req::VT_CONF_TOKEN, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for Req<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("src_ip", Self::VT_SRC_IP, false)?
     .visit_field::<super::Method>("method", Self::VT_METHOD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<super::TextEntry>>>>("args", Self::VT_ARGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<super::TextEntry>>>>("headers", Self::VT_HEADERS, false)?
     .visit_field::<u32>("conf_token", Self::VT_CONF_TOKEN, false)?
     .finish();
    Ok(())
  }
}
pub struct ReqArgs<'a> {
    pub id: u32,
    pub src_ip: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub method: super::Method,
    pub path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub args: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry<'a>>>>>,
    pub headers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry<'a>>>>>,
    pub conf_token: u32,
}
impl<'a> Default for ReqArgs<'a> {
  #[inline]
  fn default() -> Self {
    ReqArgs {
      id: 0,
      src_ip: None,
      method: super::Method::GET,
      path: None,
      args: None,
      headers: None,
      conf_token: 0,
    }
  }
}

pub struct ReqBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReqBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(Req::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_src_ip(&mut self, src_ip: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Req::VT_SRC_IP, src_ip);
  }
  #[inline]
  pub fn add_method(&mut self, method: super::Method) {
    self.fbb_.push_slot::<super::Method>(Req::VT_METHOD, method, super::Method::GET);
  }
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Req::VT_PATH, path);
  }
  #[inline]
  pub fn add_args(&mut self, args: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<super::TextEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Req::VT_ARGS, args);
  }
  #[inline]
  pub fn add_headers(&mut self, headers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<super::TextEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Req::VT_HEADERS, headers);
  }
  #[inline]
  pub fn add_conf_token(&mut self, conf_token: u32) {
    self.fbb_.push_slot::<u32>(Req::VT_CONF_TOKEN, conf_token, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReqBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReqBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Req<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Req<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Req");
      ds.field("id", &self.id());
      ds.field("src_ip", &self.src_ip());
      ds.field("method", &self.method());
      ds.field("path", &self.path());
      ds.field("args", &self.args());
      ds.field("headers", &self.headers());
      ds.field("conf_token", &self.conf_token());
      ds.finish()
  }
}
pub enum StopOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Stop<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Stop<'a> {
  type Inner = Stop<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Stop<'a> {
  pub const VT_STATUS: flatbuffers::VOffsetT = 4;
  pub const VT_HEADERS: flatbuffers::VOffsetT = 6;
  pub const VT_BODY: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Stop { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args StopArgs<'args>
  ) -> flatbuffers::WIPOffset<Stop<'bldr>> {
    let mut builder = StopBuilder::new(_fbb);
    if let Some(x) = args.body { builder.add_body(x); }
    if let Some(x) = args.headers { builder.add_headers(x); }
    builder.add_status(args.status);
    builder.finish()
  }


  #[inline]
  pub fn status(&self) -> u16 {
    self._tab.get::<u16>(Stop::VT_STATUS, Some(0)).unwrap()
  }
  #[inline]
  pub fn headers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry>>>>(Stop::VT_HEADERS, None)
  }
  #[inline]
  pub fn body(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Stop::VT_BODY, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for Stop<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("status", Self::VT_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<super::TextEntry>>>>("headers", Self::VT_HEADERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("body", Self::VT_BODY, false)?
     .finish();
    Ok(())
  }
}
pub struct StopArgs<'a> {
    pub status: u16,
    pub headers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry<'a>>>>>,
    pub body: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for StopArgs<'a> {
  #[inline]
  fn default() -> Self {
    StopArgs {
      status: 0,
      headers: None,
      body: None,
    }
  }
}

pub struct StopBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StopBuilder<'a, 'b> {
  #[inline]
  pub fn add_status(&mut self, status: u16) {
    self.fbb_.push_slot::<u16>(Stop::VT_STATUS, status, 0);
  }
  #[inline]
  pub fn add_headers(&mut self, headers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<super::TextEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Stop::VT_HEADERS, headers);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Stop::VT_BODY, body);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StopBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StopBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Stop<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Stop<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Stop");
      ds.field("status", &self.status());
      ds.field("headers", &self.headers());
      ds.field("body", &self.body());
      ds.finish()
  }
}
pub enum RewriteOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Rewrite<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Rewrite<'a> {
  type Inner = Rewrite<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Rewrite<'a> {
  pub const VT_PATH: flatbuffers::VOffsetT = 4;
  pub const VT_HEADERS: flatbuffers::VOffsetT = 6;
  pub const VT_ARGS: flatbuffers::VOffsetT = 8;
  pub const VT_RESP_HEADERS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Rewrite { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RewriteArgs<'args>
  ) -> flatbuffers::WIPOffset<Rewrite<'bldr>> {
    let mut builder = RewriteBuilder::new(_fbb);
    if let Some(x) = args.resp_headers { builder.add_resp_headers(x); }
    if let Some(x) = args.args { builder.add_args(x); }
    if let Some(x) = args.headers { builder.add_headers(x); }
    if let Some(x) = args.path { builder.add_path(x); }
    builder.finish()
  }


  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Rewrite::VT_PATH, None)
  }
  #[inline]
  pub fn headers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry>>>>(Rewrite::VT_HEADERS, None)
  }
  #[inline]
  pub fn args(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry>>>>(Rewrite::VT_ARGS, None)
  }
  #[inline]
  pub fn resp_headers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry>>>>(Rewrite::VT_RESP_HEADERS, None)
  }
}

impl flatbuffers::Verifiable for Rewrite<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<super::TextEntry>>>>("headers", Self::VT_HEADERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<super::TextEntry>>>>("args", Self::VT_ARGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<super::TextEntry>>>>("resp_headers", Self::VT_RESP_HEADERS, false)?
     .finish();
    Ok(())
  }
}
pub struct RewriteArgs<'a> {
    pub path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub headers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry<'a>>>>>,
    pub args: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry<'a>>>>>,
    pub resp_headers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry<'a>>>>>,
}
impl<'a> Default for RewriteArgs<'a> {
  #[inline]
  fn default() -> Self {
    RewriteArgs {
      path: None,
      headers: None,
      args: None,
      resp_headers: None,
    }
  }
}

pub struct RewriteBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RewriteBuilder<'a, 'b> {
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Rewrite::VT_PATH, path);
  }
  #[inline]
  pub fn add_headers(&mut self, headers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<super::TextEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Rewrite::VT_HEADERS, headers);
  }
  #[inline]
  pub fn add_args(&mut self, args: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<super::TextEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Rewrite::VT_ARGS, args);
  }
  #[inline]
  pub fn add_resp_headers(&mut self, resp_headers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<super::TextEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Rewrite::VT_RESP_HEADERS, resp_headers);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RewriteBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RewriteBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Rewrite<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Rewrite<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Rewrite");
      ds.field("path", &self.path());
      ds.field("headers", &self.headers());
      ds.field("args", &self.args());
      ds.field("resp_headers", &self.resp_headers());
      ds.finish()
  }
}
pub enum RespOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Resp<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Resp<'a> {
  type Inner = Resp<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Resp<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_ACTION_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_ACTION: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Resp { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RespArgs
  ) -> flatbuffers::WIPOffset<Resp<'bldr>> {
    let mut builder = RespBuilder::new(_fbb);
    if let Some(x) = args.action { builder.add_action(x); }
    builder.add_id(args.id);
    builder.add_action_type(args.action_type);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u32 {
    self._tab.get::<u32>(Resp::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn action_type(&self) -> Action {
    self._tab.get::<Action>(Resp::VT_ACTION_TYPE, Some(Action::NONE)).unwrap()
  }
  #[inline]
  pub fn action(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Resp::VT_ACTION, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn action_as_stop(&self) -> Option<Stop<'a>> {
    if self.action_type() == Action::Stop {
      self.action().map(Stop::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn action_as_rewrite(&self) -> Option<Rewrite<'a>> {
    if self.action_type() == Action::Rewrite {
      self.action().map(Rewrite::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Resp<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("id", Self::VT_ID, false)?
     .visit_union::<Action, _>("action_type", Self::VT_ACTION_TYPE, "action", Self::VT_ACTION, false, |key, v, pos| {
        match key {
          Action::Stop => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Stop>>("Action::Stop", pos),
          Action::Rewrite => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Rewrite>>("Action::Rewrite", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct RespArgs {
    pub id: u32,
    pub action_type: Action,
    pub action: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RespArgs {
  #[inline]
  fn default() -> Self {
    RespArgs {
      id: 0,
      action_type: Action::NONE,
      action: None,
    }
  }
}

pub struct RespBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RespBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(Resp::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_action_type(&mut self, action_type: Action) {
    self.fbb_.push_slot::<Action>(Resp::VT_ACTION_TYPE, action_type, Action::NONE);
  }
  #[inline]
  pub fn add_action(&mut self, action: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Resp::VT_ACTION, action);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RespBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RespBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Resp<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Resp<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Resp");
      ds.field("id", &self.id());
      ds.field("action_type", &self.action_type());
      match self.action_type() {
        Action::Stop => {
          if let Some(x) = self.action_as_stop() {
            ds.field("action", &x)
          } else {
            ds.field("action", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Action::Rewrite => {
          if let Some(x) = self.action_as_rewrite() {
            ds.field("action", &x)
          } else {
            ds.field("action", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("action", &x)
        },
      };
      ds.finish()
  }
}
}  // pub mod HTTPReqCall

#[allow(unused_imports, dead_code)]
pub mod extra_info {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_INFO: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_INFO: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_INFO: [Info; 4] = [
  Info::NONE,
  Info::Var,
  Info::ReqBody,
  Info::RespBody,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Info(pub u8);
#[allow(non_upper_case_globals)]
impl Info {
  pub const NONE: Self = Self(0);
  pub const Var: Self = Self(1);
  pub const ReqBody: Self = Self(2);
  pub const RespBody: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Var,
    Self::ReqBody,
    Self::RespBody,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Var => Some("Var"),
      Self::ReqBody => Some("ReqBody"),
      Self::RespBody => Some("RespBody"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Info {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Info {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Info {
    type Output = Info;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Info {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Info {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Info {}
pub struct InfoUnionTableOffset {}

pub enum VarOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Var<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Var<'a> {
  type Inner = Var<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Var<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Var { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args VarArgs<'args>
  ) -> flatbuffers::WIPOffset<Var<'bldr>> {
    let mut builder = VarBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Var::VT_NAME, None)
  }
}

impl flatbuffers::Verifiable for Var<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct VarArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for VarArgs<'a> {
  #[inline]
  fn default() -> Self {
    VarArgs {
      name: None,
    }
  }
}

pub struct VarBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VarBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Var::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VarBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VarBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Var<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Var<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Var");
      ds.field("name", &self.name());
      ds.finish()
  }
}
pub enum ReqBodyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReqBody<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReqBody<'a> {
  type Inner = ReqBody<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ReqBody<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReqBody { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args ReqBodyArgs
  ) -> flatbuffers::WIPOffset<ReqBody<'bldr>> {
    let mut builder = ReqBodyBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for ReqBody<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ReqBodyArgs {
}
impl<'a> Default for ReqBodyArgs {
  #[inline]
  fn default() -> Self {
    ReqBodyArgs {
    }
  }
}

pub struct ReqBodyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReqBodyBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReqBodyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReqBodyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReqBody<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ReqBody<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ReqBody");
      ds.finish()
  }
}
pub enum RespBodyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RespBody<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RespBody<'a> {
  type Inner = RespBody<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> RespBody<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RespBody { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args RespBodyArgs
  ) -> flatbuffers::WIPOffset<RespBody<'bldr>> {
    let mut builder = RespBodyBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for RespBody<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct RespBodyArgs {
}
impl<'a> Default for RespBodyArgs {
  #[inline]
  fn default() -> Self {
    RespBodyArgs {
    }
  }
}

pub struct RespBodyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RespBodyBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RespBodyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RespBodyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RespBody<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RespBody<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RespBody");
      ds.finish()
  }
}
pub enum ReqOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Req<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Req<'a> {
  type Inner = Req<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Req<'a> {
  pub const VT_INFO_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_INFO: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Req { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReqArgs
  ) -> flatbuffers::WIPOffset<Req<'bldr>> {
    let mut builder = ReqBuilder::new(_fbb);
    if let Some(x) = args.info { builder.add_info(x); }
    builder.add_info_type(args.info_type);
    builder.finish()
  }


  #[inline]
  pub fn info_type(&self) -> Info {
    self._tab.get::<Info>(Req::VT_INFO_TYPE, Some(Info::NONE)).unwrap()
  }
  #[inline]
  pub fn info(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Req::VT_INFO, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn info_as_var(&self) -> Option<Var<'a>> {
    if self.info_type() == Info::Var {
      self.info().map(Var::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn info_as_req_body(&self) -> Option<ReqBody<'a>> {
    if self.info_type() == Info::ReqBody {
      self.info().map(ReqBody::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn info_as_resp_body(&self) -> Option<RespBody<'a>> {
    if self.info_type() == Info::RespBody {
      self.info().map(RespBody::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Req<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Info, _>("info_type", Self::VT_INFO_TYPE, "info", Self::VT_INFO, false, |key, v, pos| {
        match key {
          Info::Var => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Var>>("Info::Var", pos),
          Info::ReqBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReqBody>>("Info::ReqBody", pos),
          Info::RespBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RespBody>>("Info::RespBody", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct ReqArgs {
    pub info_type: Info,
    pub info: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ReqArgs {
  #[inline]
  fn default() -> Self {
    ReqArgs {
      info_type: Info::NONE,
      info: None,
    }
  }
}

pub struct ReqBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReqBuilder<'a, 'b> {
  #[inline]
  pub fn add_info_type(&mut self, info_type: Info) {
    self.fbb_.push_slot::<Info>(Req::VT_INFO_TYPE, info_type, Info::NONE);
  }
  #[inline]
  pub fn add_info(&mut self, info: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Req::VT_INFO, info);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReqBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReqBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Req<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Req<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Req");
      ds.field("info_type", &self.info_type());
      match self.info_type() {
        Info::Var => {
          if let Some(x) = self.info_as_var() {
            ds.field("info", &x)
          } else {
            ds.field("info", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Info::ReqBody => {
          if let Some(x) = self.info_as_req_body() {
            ds.field("info", &x)
          } else {
            ds.field("info", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Info::RespBody => {
          if let Some(x) = self.info_as_resp_body() {
            ds.field("info", &x)
          } else {
            ds.field("info", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("info", &x)
        },
      };
      ds.finish()
  }
}
pub enum RespOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Resp<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Resp<'a> {
  type Inner = Resp<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Resp<'a> {
  pub const VT_RESULT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Resp { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RespArgs<'args>
  ) -> flatbuffers::WIPOffset<Resp<'bldr>> {
    let mut builder = RespBuilder::new(_fbb);
    if let Some(x) = args.result { builder.add_result(x); }
    builder.finish()
  }


  #[inline]
  pub fn result(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Resp::VT_RESULT, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for Resp<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("result", Self::VT_RESULT, false)?
     .finish();
    Ok(())
  }
}
pub struct RespArgs<'a> {
    pub result: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RespArgs<'a> {
  #[inline]
  fn default() -> Self {
    RespArgs {
      result: None,
    }
  }
}

pub struct RespBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RespBuilder<'a, 'b> {
  #[inline]
  pub fn add_result(&mut self, result: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Resp::VT_RESULT, result);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RespBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RespBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Resp<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Resp<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Resp");
      ds.field("result", &self.result());
      ds.finish()
  }
}
}  // pub mod ExtraInfo

#[allow(unused_imports, dead_code)]
pub mod httpresp_call {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum ReqOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Req<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Req<'a> {
  type Inner = Req<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Req<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STATUS: flatbuffers::VOffsetT = 6;
  pub const VT_HEADERS: flatbuffers::VOffsetT = 8;
  pub const VT_CONF_TOKEN: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Req { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReqArgs<'args>
  ) -> flatbuffers::WIPOffset<Req<'bldr>> {
    let mut builder = ReqBuilder::new(_fbb);
    builder.add_conf_token(args.conf_token);
    if let Some(x) = args.headers { builder.add_headers(x); }
    builder.add_id(args.id);
    builder.add_status(args.status);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u32 {
    self._tab.get::<u32>(Req::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn status(&self) -> u16 {
    self._tab.get::<u16>(Req::VT_STATUS, Some(0)).unwrap()
  }
  #[inline]
  pub fn headers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry>>>>(Req::VT_HEADERS, None)
  }
  #[inline]
  pub fn conf_token(&self) -> u32 {
    self._tab.get::<u32>(Req::VT_CONF_TOKEN, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for Req<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("id", Self::VT_ID, false)?
     .visit_field::<u16>("status", Self::VT_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<super::TextEntry>>>>("headers", Self::VT_HEADERS, false)?
     .visit_field::<u32>("conf_token", Self::VT_CONF_TOKEN, false)?
     .finish();
    Ok(())
  }
}
pub struct ReqArgs<'a> {
    pub id: u32,
    pub status: u16,
    pub headers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry<'a>>>>>,
    pub conf_token: u32,
}
impl<'a> Default for ReqArgs<'a> {
  #[inline]
  fn default() -> Self {
    ReqArgs {
      id: 0,
      status: 0,
      headers: None,
      conf_token: 0,
    }
  }
}

pub struct ReqBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReqBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(Req::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_status(&mut self, status: u16) {
    self.fbb_.push_slot::<u16>(Req::VT_STATUS, status, 0);
  }
  #[inline]
  pub fn add_headers(&mut self, headers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<super::TextEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Req::VT_HEADERS, headers);
  }
  #[inline]
  pub fn add_conf_token(&mut self, conf_token: u32) {
    self.fbb_.push_slot::<u32>(Req::VT_CONF_TOKEN, conf_token, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReqBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReqBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Req<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Req<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Req");
      ds.field("id", &self.id());
      ds.field("status", &self.status());
      ds.field("headers", &self.headers());
      ds.field("conf_token", &self.conf_token());
      ds.finish()
  }
}
pub enum RespOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Resp<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Resp<'a> {
  type Inner = Resp<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Resp<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STATUS: flatbuffers::VOffsetT = 6;
  pub const VT_HEADERS: flatbuffers::VOffsetT = 8;
  pub const VT_BODY: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Resp { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RespArgs<'args>
  ) -> flatbuffers::WIPOffset<Resp<'bldr>> {
    let mut builder = RespBuilder::new(_fbb);
    if let Some(x) = args.body { builder.add_body(x); }
    if let Some(x) = args.headers { builder.add_headers(x); }
    builder.add_id(args.id);
    builder.add_status(args.status);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u32 {
    self._tab.get::<u32>(Resp::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn status(&self) -> u16 {
    self._tab.get::<u16>(Resp::VT_STATUS, Some(0)).unwrap()
  }
  #[inline]
  pub fn headers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry>>>>(Resp::VT_HEADERS, None)
  }
  #[inline]
  pub fn body(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Resp::VT_BODY, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for Resp<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("id", Self::VT_ID, false)?
     .visit_field::<u16>("status", Self::VT_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<super::TextEntry>>>>("headers", Self::VT_HEADERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("body", Self::VT_BODY, false)?
     .finish();
    Ok(())
  }
}
pub struct RespArgs<'a> {
    pub id: u32,
    pub status: u16,
    pub headers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::TextEntry<'a>>>>>,
    pub body: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RespArgs<'a> {
  #[inline]
  fn default() -> Self {
    RespArgs {
      id: 0,
      status: 0,
      headers: None,
      body: None,
    }
  }
}

pub struct RespBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RespBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(Resp::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_status(&mut self, status: u16) {
    self.fbb_.push_slot::<u16>(Resp::VT_STATUS, status, 0);
  }
  #[inline]
  pub fn add_headers(&mut self, headers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<super::TextEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Resp::VT_HEADERS, headers);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Resp::VT_BODY, body);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RespBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RespBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Resp<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Resp<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Resp");
      ds.field("id", &self.id());
      ds.field("status", &self.status());
      ds.field("headers", &self.headers());
      ds.field("body", &self.body());
      ds.finish()
  }
}
}  // pub mod HTTPRespCall
}  // pub mod A6

